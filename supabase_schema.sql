-- Usuwanie istniejących tabel (jeśli istnieją)
DROP TABLE IF EXISTS public.profiles CASCADE;
DROP TABLE IF EXISTS public.divisions CASCADE;
DROP TABLE IF EXISTS public.roles CASCADE;

-- Tworzenie tabeli 'roles'
CREATE TABLE public.roles (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name TEXT NOT NULL UNIQUE,
    level INTEGER NOT NULL
);

-- Wstawianie domyślnych ról
INSERT INTO public.roles (name, level) VALUES
('Officer', 1),
('Sergeant', 2),
('Lieutenant', 3),
('Captain', 4),
('High Command', 5);

-- Tworzenie tabeli 'divisions'
CREATE TABLE public.divisions (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name TEXT NOT NULL UNIQUE,
    description TEXT
);

-- Wstawianie domyślnych dywizji
INSERT INTO public.divisions (name, description) VALUES
('Patrol Division', 'Odpowiedzialna za patrole i reagowanie na zgłoszenia.'),
('Detective Bureau', 'Prowadzi dochodzenia w sprawach kryminalnych.'),
('Traffic Division', 'Zajmuje się egzekwowaniem przepisów ruchu drogowego.'),
('SWAT Team', 'Jednostka specjalna do zadań wysokiego ryzyka.');

-- Tworzenie tabeli 'profiles'
CREATE TABLE public.profiles (
    id UUID REFERENCES auth.users(id) ON DELETE CASCADE PRIMARY KEY,
    email TEXT NOT NULL UNIQUE,
    badge_number TEXT NOT NULL UNIQUE,
    first_name TEXT,
    last_name TEXT,
    role_id BIGINT REFERENCES public.roles(id) NOT NULL,
    division_id BIGINT REFERENCES public.divisions(id),
    status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'approved', 'rejected')),
    avatar_url TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indeksy dla szybszego wyszukiwania
CREATE INDEX idx_profiles_email ON public.profiles (email);
CREATE INDEX idx_profiles_badge_number ON public.profiles (badge_number);
CREATE INDEX idx_profiles_role_id ON public.profiles (role_id);
CREATE INDEX idx_profiles_division_id ON public.profiles (division_id);

-- Ustawienie funkcji do aktualizacji 'updated_at'
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ language 'plpgsql';

CREATE TRIGGER update_profiles_updated_at
BEFORE UPDATE ON public.profiles
FOR EACH ROW
EXECUTE FUNCTION update_updated_at_column();

-- Włączanie Row Level Security (RLS) dla tabeli 'profiles'
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- Tworzenie funkcji pomocniczej do pobierania poziomu roli użytkownika
CREATE OR REPLACE FUNCTION public.get_user_role_level()
 RETURNS integer
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
    DECLARE
        user_role_level integer;
    BEGIN
        SELECT r.level
        INTO user_role_level
        FROM public.profiles p
        JOIN public.roles r ON p.role_id = r.id
        WHERE p.id = auth.uid();

        RETURN COALESCE(user_role_level, 0); -- Zwraca 0, jeśli rola nie została znaleziona (np. niezalogowany użytkownik)
    END;
$function$;

-- Polityki RLS dla tabeli 'profiles'
-- Użytkownicy mogą czytać swój własny profil
CREATE POLICY "Users can view their own profile" ON public.profiles
FOR SELECT USING (auth.uid() = id);

-- Użytkownicy mogą aktualizować swój własny profil
CREATE POLICY "Users can update their own profile" ON public.profiles
FOR UPDATE USING (auth.uid() = id) WITH CHECK (auth.uid() = id);

-- Użytkownicy mogą tworzyć swój profil (po rejestracji)
CREATE POLICY "Users can create their own profile" ON public.profiles
FOR INSERT WITH CHECK (auth.uid() = id);

-- Administratorzy (Lieutenant i wyżej) mogą czytać wszystkie profile
CREATE POLICY "Admins can view all profiles" ON public.profiles
FOR SELECT USING (public.get_user_role_level() >= (SELECT level FROM public.roles WHERE name = 'Lieutenant'));

-- Administratorzy (Lieutenant i wyżej) mogą aktualizować wszystkie profile
CREATE POLICY "Admins can update all profiles" ON public.profiles
FOR UPDATE USING (public.get_user_role_level() >= (SELECT level FROM public.roles WHERE name = 'Lieutenant'));

-- Administratorzy (High Command) mogą usuwać profile
CREATE POLICY "High Command can delete profiles" ON public.profiles
FOR DELETE USING (public.get_user_role_level() >= (SELECT level FROM public.roles WHERE name = 'High Command'));

-- Włączanie RLS dla tabel 'roles' i 'divisions' (tylko do odczytu dla wszystkich)
ALTER TABLE public.roles ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Enable read access for all users" ON public.roles
FOR SELECT USING (TRUE);

ALTER TABLE public.divisions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Enable read access for all users" ON public.divisions
FOR SELECT USING (TRUE);